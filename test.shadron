#include <math_constants>
#include <multisample>
#include <affine_transform>
#include <debug>
#include <dither>
#include <blending>
#include <shapes>

image Gravestone = file("gravestone.png") :filter(nearest);


parameter float intensity = 0.3 : range(0.0, 1.0);

const vec2 ZERO2 = vec2(0, 0);
const vec3 ZERO3 = vec3(0, 0, 0);
const vec4 ZERO4 = vec4(0, 0, 0, 0);

const vec2 ONE2 = vec2(1, 1);
const vec3 ONE3 = vec3(1, 1, 1);
const vec4 ONE4 = vec4(1, 1, 1, 1);

const vec4 WHITE = vec4( 1, 1, 1, 1);
const vec4 BLACK = vec4( 0, 0, 0, 1);
const vec4 BLUE = vec4( 0, 0, 1, 1);


const int sides = 36 * 16;
const ivec2 IMG_SIZE = ivec2(16, 16);
const ivec2 SIZE = vec2(sides, sides);

glsl bool should_print_at_offset(vec2 position, float val, ivec2 offset) {
    ivec2 test_pos = ivec2(shadron_Dimensions*position);
    return printValue(val, test_pos/2 - offset);
};

glsl bool should_print_mouse_x(vec2 position) {
    return should_print_at_offset( position, shadron_Mouse.x, ivec2(80.5, 0));
};

glsl bool should_print_mouse_y(vec2 position) {
    return should_print_at_offset( position, shadron_Mouse.y, ivec2(80.5, 25));
};

glsl bool should_print_mouse_z(vec2 position) {
    return should_print_at_offset( position, shadron_Mouse.z, ivec2(80.5, 50));
};

glsl bool should_print_mouse(vec2 position) {
    if ( should_print_mouse_x(position) ) { return true; }
    if ( should_print_mouse_y(position) ) { return true; }
    // if ( should_print_mouse_z(position) ) { return true; }

    return false;
};

glsl vec2 my_norm(vec2 val, vec2 min, vec2 max) {
    return (val - min) / (max - min);
};

glsl vec2 my_denorm(vec2 normed, vec2 min, vec2 max) {
    return normed * (max - min) + min;
};

glsl vec4 drawRectAndPrintMouseCoords(vec2 position) {
    if (should_print_mouse(position)) { return BLUE; }

    ivec2 dim_pos = ivec2(shadron_Dimensions*position);
    vec2 origin = vec2(0.3, 0.2);
    float size = 0.3f;
    vec2 bl = origin;
    vec2 tr = origin + vec2(size, size*2);
    if (rectangle(position, bl, tr) == 1)
    {
        vec2 pos = position;

        pos = my_denorm(pos, ZERO2, ONE2);
        pos = my_norm(pos, bl, tr);
        vec4 result = texture(Gravestone, pos);
        return result;
    };

    return texture(Gravestone, position);
}

// The generated cubemap
image Test = glsl(drawRectAndPrintMouseCoords, SIZE);
