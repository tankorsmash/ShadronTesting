#include <math_constants>
#include <debug>
#include <dither>
#include <shapes>

image Gravestone = file("gravestone.png") :filter(nearest);


parameter float intensity = 0.3 : range(0.3, 0.9);


const vec4 WHITE = vec4( 1, 1, 1, 1);
const vec4 BLACK = vec4( 0, 0, 0, 1);
const vec4 BLUE = vec4( 0, 0, 1, 1);

glsl bool should_print_at_offset(vec2 position, float val, ivec2 offset) {
    ivec2 test_pos = ivec2(shadron_Dimensions*position);
    return printValue(val, test_pos/2 - offset);
};

glsl bool should_print_mouse_x(vec2 position) {
    return should_print_at_offset( position, shadron_Mouse.x, ivec2(80.5, 0));
};

glsl bool should_print_mouse_y(vec2 position) {
    return should_print_at_offset( position, shadron_Mouse.y, ivec2(80.5, 25));
};

glsl bool should_print_mouse_z(vec2 position) {
    return should_print_at_offset( position, shadron_Mouse.z, ivec2(80.5, 50));
};

glsl vec4 drawRectAndPrintMouseCoords(vec2 position) {
    ivec2 dim_pos = ivec2(shadron_Dimensions*position);

    //pretty print mouse pos
    float val = shadron_Time;
    if (should_print_mouse_x(position)) { return BLUE; }
    if (should_print_at_offset(position, shadron_DeltaTime, ivec2(80, 50))) { return BLUE; }


    vec4 sample = texture(Gravestone, position);
    float dithered = dither<4>(ivec2(dim_pos));
    if (sample.a != 0) {
        sample*= dithered;
    };
    return sample;
}

const int sides = 36 * 16;
const ivec2 SIZE = vec2(sides, sides);

// The generated cubemap
animation Test = glsl(drawRectAndPrintMouseCoords, SIZE);
